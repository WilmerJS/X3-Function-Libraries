# ================================================================================================ #
#
#   AKTIEBOLAGET SYSTEMSTÖD SVERIGE
#
#     Wilmer Jensen Sternehäll
#     wilmer.sternehall@systemstod.se
#
#   ---
#     Name:
#       XSS_SORDER
#     Description:
#       A Systemstöd function library script containing custom Sage X3 functions developed
#       in a general, comprehensive manner meant to fit any Sage X3 installation.
#
#       The functions in this file are related to SALES ORDER MANAGEMENT.
#
#
#
#   Copyright @ 2018 - 2020, Aktiebolaget Systemstöd Sverige
#
#
# ================================================================================================ #

##############################################################################################################
# < WIST >
#**
#* Checks if an order line will be deliverable at the specified date, by calculating if the
#* product quantity in stock will be enough to satisfy it based on its priority (CREDATTIM).
#* <pre></pre>
#*
#* This function takes into account order lines with a higher priority (earlier CREDATTIM)
#* than the one that is being checked, and assigns items to them first. If any stock quantity
#* remains, the order line being checked may be delivered.
#* <pre></pre>
#*
#* @param ORDER_NUM Order number
#* @param LINE Order line
#* @param SEQUENCE Order line sequence
#* @param XDATE Date to check if line can be delivered on
#*
#* @return An integer value
#* <pre>
#* 1 = line is deliverable
#* 0 = line is not deliverable
#* </pre>
#*!
Funprog IS_ORDER_LINE_DELIVERABLE_AT_DATE(ORDER_NUM, LINE, SEQUENCE, XDATE)
Value Char ORDER_NUM
Value Integer LINE
Value Integer SEQUENCE
Value Date XDATE

  If clalev([YSOQ])=0 : Local File SORDERQ [YSOQ] : Endif

  Read [YSOQ]SOQ0 = ORDER_NUM ; LINE ; SEQUENCE

  Local Date DATE_OF_NEXT_RECEIPT
  Local Date LEADTIME_LIMIT
  Local Date DATE_CHECK_EXCESS
  Local Decimal QTY_AVAILABLE

  LEADTIME_LIMIT = func XSS_STOCK.GET_THEORETICAL_LEADTIME_LIMIT([YSOQ]STOFCY, [YSOQ]ITMREF)

  DATE_OF_NEXT_RECEIPT = func XSS_PORDER.GET_NEXT_RECEIPT_DATE_BY_ITEM([YSOQ]STOFCY, [YSOQ]ITMREF, XDATE + 1)
  DATE_OF_NEXT_RECEIPT = func XSS_VARIABLES.IS_NULL(DATE_OF_NEXT_RECEIPT, LEADTIME_LIMIT)

  DATE_CHECK_EXCESS = min(DATE_OF_NEXT_RECEIPT, LEADTIME_LIMIT) - 1

  #Infbox num$(XDATE), num$(DATE_OF_NEXT_RECEIPT), num$(LEADTIME_LIMIT), num$(DATE_CHECK_EXCESS)

  QTY_AVAILABLE = func XSS_STOCK.GET_ITEM_AVAILABILITY_AT_DATE_BY_PRIO([YSOQ]STOFCY, [YSOQ]ITMREF, DATE_CHECK_EXCESS, [YSOQ]DEMNUM)

  If QTY_AVAILABLE >= ([YSOQ]QTYSTU - [YSOQ]DLVQTYSTU)
    End 1
  Endif

End 0

##############################################################################################################
# < WIST >
#**
#* Gets the first date an order line can be delivered, by returning the first date that the expected stock
#* quantity can satisfy this order line.
#* <pre></pre>
#*
#* This functions takes into account lines with the same requested delivery date from all orders,
#* and prioritizes the ones with a <b>lower order number</b>.
#* <pre></pre>
#*
#* @param ORDER_NUM Order number
#* @param LINE Order line
#* @param SEQUENCE Order line sequence
#*
#* @return The first expected delivery date
#*!
Funprog GET_ORDER_LINE_DELIVERABLE_DATE(ORDER_NUM, LINE, SEQUENCE)
Value Char ORDER_NUM
Value Integer LINE
Value Integer SEQUENCE

  If clalev([YSOQ])=0 : Local File SORDERQ [YSOQ] : Endif

  Read [YSOQ]SOQ0 = ORDER_NUM ; LINE ; SEQUENCE

  Local Date CUSTOMER_REQUEST_DATE    # customers requested date OR today, whichever is largest
  Local Date LEADTIME_LIMIT           # lead time limit
  Local Date DELIVERY_DATE            # the final delivery date
  Local Date CHECK_DATE               # variable to check whether dates are OK to deliver on
  Local Date EARLIEST_DATE_TO_CHECK   # don't check earlier than this date. (first incoming purchase order)

  CUSTOMER_REQUEST_DATE = max([YSOQ]DEMDLVDAT, date$)
  LEADTIME_LIMIT        = func XSS_STOCK.GET_THEORETICAL_LEADTIME_LIMIT([YSOQ]STOFCY, [YSOQ]ITMREF)
  DELIVERY_DATE         = LEADTIME_LIMIT  # start here, then check if we can deliver earlier
  CHECK_DATE            = LEADTIME_LIMIT  # lead time date won't actually be checked, CHECK_DATE is reassigned before first check

  If CUSTOMER_REQUEST_DATE > LEADTIME_LIMIT
    End CUSTOMER_REQUEST_DATE
  Endif

  # min function is unnecessary because we call IS_NULL afterwards anyway.
  #EARLIEST_DATE_TO_CHECK = min(date$, func XSS_PORDER.GET_NEXT_RECEIPT_DATE_BY_ITEM([YSOQ]STOFCY, [YSOQ]ITMREF, date$ + 1))

  EARLIEST_DATE_TO_CHECK = func XSS_PORDER.GET_NEXT_RECEIPT_DATE_BY_ITEM([YSOQ]STOFCY, [YSOQ]ITMREF, date$ + 1)
  EARLIEST_DATE_TO_CHECK = func XSS_VARIABLES.IS_NULL(EARLIEST_DATE_TO_CHECK, date$)

  Repeat

    CHECK_DATE = max(EARLIEST_DATE_TO_CHECK, func XSS_PORDER.GET_LAST_RECEIPT_DATE_BY_ITEM([YSOQ]STOFCY, [YSOQ]ITMREF, CHECK_DATE - 1))

    Infbox "CHECKING IF ORDER: " + ORDER_NUM + ", LINE: " + num$(LINE),
&          "CAN BE DELIVERED AT: " + num$(CHECK_DATE)

    If (func IS_ORDER_LINE_DELIVERABLE_AT_DATE(ORDER_NUM, LINE, SEQUENCE, CHECK_DATE))
      DELIVERY_DATE = CHECK_DATE
      Infbox "Delivery date OK: " + num$(CHECK_DATE)
    Else
      Infbox "Delivery date NOT OK: " + num$(CHECK_DATE)
      Break
    Endif

  Until CHECK_DATE = EARLIEST_DATE_TO_CHECK

  # TODO : BRYTPUNKT

End DELIVERY_DATE

